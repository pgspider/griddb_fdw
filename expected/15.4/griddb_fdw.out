\set ECHO none
--Testcase 1:
CREATE EXTENSION griddb_fdw;
--Testcase 2:
CREATE SERVER griddb_svr FOREIGN DATA WRAPPER griddb_fdw OPTIONS (host :GRIDDB_HOST, port :GRIDDB_PORT, clustername 'griddbfdwTestCluster');
--Testcase 3:
CREATE USER MAPPING FOR public SERVER griddb_svr OPTIONS (username :GRIDDB_USER, password :GRIDDB_PASS);
IMPORT FOREIGN SCHEMA griddb_schema FROM SERVER griddb_svr INTO public;
-- GridDB containers must be created for this test on GridDB server
/*
CREATE TABLE department (department_id integer primary key, department_name text)
CREATE TABLE employee (emp_id integer primary key, emp_name text, emp_dept_id integer)
CREATE TABLE empdata (emp_id integer primary key, emp_dat blob)
CREATE TABLE numbers (a integer primary key, b text)
CREATE TABLE shorty (id integer primary key, c text)
CREATE TABLE evennumbers (a integer primary key, b text)
*/
--Testcase 4:
DELETE FROM department;
--Testcase 5:
DELETE FROM employee;
--Testcase 6:
DELETE FROM empdata;
--Testcase 7:
DELETE FROM numbers;
--Testcase 8:
DELETE FROM evennumbers;
--Testcase 9:
DELETE FROM rowkey_tbl;
--Testcase 10:
SELECT * FROM department LIMIT 10;
 department_id | department_name 
---------------+-----------------
(0 rows)

--Testcase 11:
SELECT * FROM employee LIMIT 10;
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
(0 rows)

--Testcase 12:
SELECT * FROM empdata LIMIT 10;
 emp_id | emp_dat 
--------+---------
(0 rows)

--Testcase 13:
INSERT INTO department VALUES(generate_series(1,100), 'dept - ' || generate_series(1,100));
--Testcase 14:
INSERT INTO employee VALUES(generate_series(1,100), 'emp - ' || generate_series(1,100), generate_series(1,100));
--Testcase 15:
INSERT INTO empdata  VALUES(1, decode ('01234567', 'hex'));
--Testcase 16:
INSERT INTO numbers VALUES(1, 'One');
--Testcase 17:
INSERT INTO numbers VALUES(2, 'Two');
--Testcase 18:
INSERT INTO numbers VALUES(3, 'Three');
--Testcase 19:
INSERT INTO numbers VALUES(4, 'Four');
--Testcase 20:
INSERT INTO numbers VALUES(5, 'Five');
--Testcase 21:
INSERT INTO numbers VALUES(6, 'Six');
--Testcase 22:
INSERT INTO numbers VALUES(7, 'Seven');
--Testcase 23:
INSERT INTO numbers VALUES(8, 'Eight');
--Testcase 24:
INSERT INTO numbers VALUES(9, 'Nine');
--Testcase 25:
INSERT INTO evennumbers VALUES(2, 'Two');
--Testcase 26:
INSERT INTO evennumbers VALUES(4, 'Four');
--Testcase 27:
INSERT INTO evennumbers VALUES(6, 'Six');
--Testcase 28:
INSERT INTO evennumbers VALUES(8, 'Eight');
--Testcase 29:
SELECT count(*) FROM department;
 count 
-------
   100
(1 row)

--Testcase 30:
SELECT count(*) FROM employee;
 count 
-------
   100
(1 row)

--Testcase 31:
SELECT count(*) FROM empdata;
 count 
-------
     1
(1 row)

-- Join
--Testcase 32:
SELECT * FROM department d, employee e WHERE d.department_id = e.emp_dept_id LIMIT 10;
 department_id | department_name | emp_id | emp_name | emp_dept_id 
---------------+-----------------+--------+----------+-------------
             1 | dept - 1        |      1 | emp - 1  |           1
             2 | dept - 2        |      2 | emp - 2  |           2
             3 | dept - 3        |      3 | emp - 3  |           3
             4 | dept - 4        |      4 | emp - 4  |           4
             5 | dept - 5        |      5 | emp - 5  |           5
             6 | dept - 6        |      6 | emp - 6  |           6
             7 | dept - 7        |      7 | emp - 7  |           7
             8 | dept - 8        |      8 | emp - 8  |           8
             9 | dept - 9        |      9 | emp - 9  |           9
            10 | dept - 10       |     10 | emp - 10 |          10
(10 rows)

-- Subquery
--Testcase 33:
SELECT * FROM department d, employee e WHERE d.department_id IN (SELECT department_id FROM department) LIMIT 10;
 department_id | department_name | emp_id | emp_name | emp_dept_id 
---------------+-----------------+--------+----------+-------------
             1 | dept - 1        |      1 | emp - 1  |           1
             1 | dept - 1        |      2 | emp - 2  |           2
             1 | dept - 1        |      3 | emp - 3  |           3
             1 | dept - 1        |      4 | emp - 4  |           4
             1 | dept - 1        |      5 | emp - 5  |           5
             1 | dept - 1        |      6 | emp - 6  |           6
             1 | dept - 1        |      7 | emp - 7  |           7
             1 | dept - 1        |      8 | emp - 8  |           8
             1 | dept - 1        |      9 | emp - 9  |           9
             1 | dept - 1        |     10 | emp - 10 |          10
(10 rows)

--Testcase 34:
SELECT * FROM empdata;
 emp_id |  emp_dat   
--------+------------
      1 | \x01234567
(1 row)

-- Delete single row
--Testcase 35:
DELETE FROM employee WHERE emp_id = 10;
--Testcase 36:
SELECT COUNT(*) FROM department LIMIT 10;
 count 
-------
   100
(1 row)

--Testcase 37:
SELECT COUNT(*) FROM employee WHERE emp_id = 10;
 count 
-------
     0
(1 row)

-- Update single row
--Testcase 38:
UPDATE employee SET emp_name = 'Updated emp' WHERE emp_id = 20;
--Testcase 39:
SELECT emp_id, emp_name FROM employee WHERE emp_name like 'Updated emp';
 emp_id |  emp_name   
--------+-------------
     20 | Updated emp
(1 row)

--Testcase 40:
UPDATE empdata SET emp_dat = decode ('0123', 'hex');
--Testcase 41:
SELECT * FROM empdata;
 emp_id | emp_dat 
--------+---------
      1 | \x0123
(1 row)

--Testcase 42:
SELECT * FROM employee LIMIT 10;
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
      1 | emp - 1  |           1
      2 | emp - 2  |           2
      3 | emp - 3  |           3
      4 | emp - 4  |           4
      5 | emp - 5  |           5
      6 | emp - 6  |           6
      7 | emp - 7  |           7
      8 | emp - 8  |           8
      9 | emp - 9  |           9
     11 | emp - 11 |          11
(10 rows)

--Testcase 43:
SELECT * FROM employee WHERE emp_id IN (1);
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
      1 | emp - 1  |           1
(1 row)

--Testcase 44:
SELECT * FROM employee WHERE emp_id IN (1,3,4,5);
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
      1 | emp - 1  |           1
      3 | emp - 3  |           3
      4 | emp - 4  |           4
      5 | emp - 5  |           5
(4 rows)

--Testcase 45:
SELECT * FROM employee WHERE emp_id IN (10000,1000);
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
(0 rows)

--Testcase 46:
SELECT * FROM employee WHERE emp_id NOT IN (1) LIMIT 5;
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
      2 | emp - 2  |           2
      3 | emp - 3  |           3
      4 | emp - 4  |           4
      5 | emp - 5  |           5
      6 | emp - 6  |           6
(5 rows)

--Testcase 47:
SELECT * FROM employee WHERE emp_id NOT IN (1,3,4,5) LIMIT 5;
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
      2 | emp - 2  |           2
      6 | emp - 6  |           6
      7 | emp - 7  |           7
      8 | emp - 8  |           8
      9 | emp - 9  |           9
(5 rows)

--Testcase 48:
SELECT * FROM employee WHERE emp_id NOT IN (10000,1000) LIMIT 5;
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
      1 | emp - 1  |           1
      2 | emp - 2  |           2
      3 | emp - 3  |           3
      4 | emp - 4  |           4
      5 | emp - 5  |           5
(5 rows)

--Testcase 49:
SELECT * FROM employee WHERE emp_id NOT IN (SELECT emp_id FROM employee WHERE emp_id IN (1,10));
 emp_id |  emp_name   | emp_dept_id 
--------+-------------+-------------
      2 | emp - 2     |           2
      3 | emp - 3     |           3
      4 | emp - 4     |           4
      5 | emp - 5     |           5
      6 | emp - 6     |           6
      7 | emp - 7     |           7
      8 | emp - 8     |           8
      9 | emp - 9     |           9
     11 | emp - 11    |          11
     12 | emp - 12    |          12
     13 | emp - 13    |          13
     14 | emp - 14    |          14
     15 | emp - 15    |          15
     16 | emp - 16    |          16
     17 | emp - 17    |          17
     18 | emp - 18    |          18
     19 | emp - 19    |          19
     20 | Updated emp |          20
     21 | emp - 21    |          21
     22 | emp - 22    |          22
     23 | emp - 23    |          23
     24 | emp - 24    |          24
     25 | emp - 25    |          25
     26 | emp - 26    |          26
     27 | emp - 27    |          27
     28 | emp - 28    |          28
     29 | emp - 29    |          29
     30 | emp - 30    |          30
     31 | emp - 31    |          31
     32 | emp - 32    |          32
     33 | emp - 33    |          33
     34 | emp - 34    |          34
     35 | emp - 35    |          35
     36 | emp - 36    |          36
     37 | emp - 37    |          37
     38 | emp - 38    |          38
     39 | emp - 39    |          39
     40 | emp - 40    |          40
     41 | emp - 41    |          41
     42 | emp - 42    |          42
     43 | emp - 43    |          43
     44 | emp - 44    |          44
     45 | emp - 45    |          45
     46 | emp - 46    |          46
     47 | emp - 47    |          47
     48 | emp - 48    |          48
     49 | emp - 49    |          49
     50 | emp - 50    |          50
     51 | emp - 51    |          51
     52 | emp - 52    |          52
     53 | emp - 53    |          53
     54 | emp - 54    |          54
     55 | emp - 55    |          55
     56 | emp - 56    |          56
     57 | emp - 57    |          57
     58 | emp - 58    |          58
     59 | emp - 59    |          59
     60 | emp - 60    |          60
     61 | emp - 61    |          61
     62 | emp - 62    |          62
     63 | emp - 63    |          63
     64 | emp - 64    |          64
     65 | emp - 65    |          65
     66 | emp - 66    |          66
     67 | emp - 67    |          67
     68 | emp - 68    |          68
     69 | emp - 69    |          69
     70 | emp - 70    |          70
     71 | emp - 71    |          71
     72 | emp - 72    |          72
     73 | emp - 73    |          73
     74 | emp - 74    |          74
     75 | emp - 75    |          75
     76 | emp - 76    |          76
     77 | emp - 77    |          77
     78 | emp - 78    |          78
     79 | emp - 79    |          79
     80 | emp - 80    |          80
     81 | emp - 81    |          81
     82 | emp - 82    |          82
     83 | emp - 83    |          83
     84 | emp - 84    |          84
     85 | emp - 85    |          85
     86 | emp - 86    |          86
     87 | emp - 87    |          87
     88 | emp - 88    |          88
     89 | emp - 89    |          89
     90 | emp - 90    |          90
     91 | emp - 91    |          91
     92 | emp - 92    |          92
     93 | emp - 93    |          93
     94 | emp - 94    |          94
     95 | emp - 95    |          95
     96 | emp - 96    |          96
     97 | emp - 97    |          97
     98 | emp - 98    |          98
     99 | emp - 99    |          99
    100 | emp - 100   |         100
(98 rows)

--Testcase 50:
SELECT * FROM employee WHERE emp_name NOT IN ('emp - 1', 'emp - 2') LIMIT 5;
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
      3 | emp - 3  |           3
      4 | emp - 4  |           4
      5 | emp - 5  |           5
      6 | emp - 6  |           6
      7 | emp - 7  |           7
(5 rows)

--Testcase 51:
SELECT * FROM employee WHERE emp_name NOT IN ('emp - 10') LIMIT 5;
 emp_id | emp_name | emp_dept_id 
--------+----------+-------------
      1 | emp - 1  |           1
      2 | emp - 2  |           2
      3 | emp - 3  |           3
      4 | emp - 4  |           4
      5 | emp - 5  |           5
(5 rows)

--Testcase 52:
CREATE OR REPLACE FUNCTION test_param_where() RETURNS void AS $$
DECLARE
  n varchar;
BEGIN
  FOR x IN 1..9 LOOP

--Testcase 53:
    SELECT b INTO n FROM numbers WHERE a=x;
    RAISE NOTICE 'Found number %', n;
  END LOOP;
  RETURN;
END
$$ LANGUAGE plpgsql;
--Testcase 54:
SELECT test_param_where();
NOTICE:  Found number One
NOTICE:  Found number Two
NOTICE:  Found number Three
NOTICE:  Found number Four
NOTICE:  Found number Five
NOTICE:  Found number Six
NOTICE:  Found number Seven
NOTICE:  Found number Eight
NOTICE:  Found number Nine
 test_param_where 
------------------
 
(1 row)

--Testcase 55:
ALTER FOREIGN TABLE numbers OPTIONS (table_name 'evennumbers');
--Testcase 56:
INSERT INTO numbers VALUES(10, 'Ten');
--Testcase 57:
SELECT * FROM numbers;
 a  |   b   
----+-------
  2 | Two
  4 | Four
  6 | Six
  8 | Eight
 10 | Ten
(5 rows)

--Testcase 58:
SET griddbfdw.enable_partial_execution TO TRUE;
--Testcase 59:
SELECT * FROM numbers;
 a  |   b   
----+-------
  2 | Two
  4 | Four
  6 | Six
  8 | Eight
 10 | Ten
(5 rows)

--Testcase 60:
SET griddbfdw.enable_partial_execution TO FALSE;
--Testcase 61:
DELETE FROM employee;
--Testcase 62:
DELETE FROM department;
--Testcase 63:
DELETE FROM empdata;
--Testcase 64:
DELETE FROM numbers;
--Testcase 65:
DROP FUNCTION test_param_where();
--Testcase 66:
DROP FOREIGN TABLE numbers;
--Testcase 67:
DROP FOREIGN TABLE department;
--Testcase 68:
DROP FOREIGN TABLE employee;
--Testcase 69:
DROP FOREIGN TABLE empdata;
-- -----------------------------------------------------------------------------
--Testcase 70:
DELETE FROM shorty;
--Testcase 71:
INSERT INTO shorty (id, c) VALUES (1, 'Z');
--Testcase 72:
INSERT INTO shorty (id, c) VALUES (2, 'Y');
--Testcase 73:
INSERT INTO shorty (id, c) VALUES (5, 'A');
--Testcase 74:
INSERT INTO shorty (id, c) VALUES (3, 'X');
--Testcase 75:
INSERT INTO shorty (id, c) VALUES (4, 'B');
-- ORDER BY.
--Testcase 76:
SELECT c FROM shorty ORDER BY id;
 c 
---
 Z
 Y
 X
 B
 A
(5 rows)

-- Transaction INSERT
BEGIN;
--Testcase 77:
INSERT INTO shorty (id, c) VALUES (6, 'T');
ROLLBACK;
--Testcase 78:
SELECT id, c FROM shorty;
 id | c 
----+---
  1 | Z
  2 | Y
  5 | A
  3 | X
  4 | B
(5 rows)

-- Transaction UPDATE single row
BEGIN;
--Testcase 79:
UPDATE shorty SET c = 'd' WHERE id = 5;
ROLLBACK;
--Testcase 80:
SELECT id, c FROM shorty;
 id | c 
----+---
  1 | Z
  2 | Y
  5 | A
  3 | X
  4 | B
(5 rows)

-- Transaction UPDATE all
BEGIN;
--Testcase 81:
UPDATE shorty SET c = 'd';
ROLLBACK;
--Testcase 82:
SELECT id, c FROM shorty;
 id | c 
----+---
  1 | Z
  2 | Y
  5 | A
  3 | X
  4 | B
(5 rows)

-- Transaction DELETE single row
BEGIN;
--Testcase 83:
DELETE FROM shorty WHERE id = 1;
ROLLBACK;
--Testcase 84:
SELECT id, c FROM shorty;
 id | c 
----+---
  1 | Z
  2 | Y
  5 | A
  3 | X
  4 | B
(5 rows)

-- Transaction DELETE all
BEGIN;
--Testcase 85:
DELETE FROM shorty;
ROLLBACK;
--Testcase 86:
SELECT id, c FROM shorty;
 id | c 
----+---
  1 | Z
  2 | Y
  5 | A
  3 | X
  4 | B
(5 rows)

-- Use of NULL value
BEGIN;
--Testcase 87:
INSERT INTO shorty VALUES(99, NULL);
--Testcase 88:
UPDATE shorty SET c = NULL WHERE id = 3;
--Testcase 89:
SELECT id FROM shorty WHERE c IS NULL;
 id 
----
  3
 99
(2 rows)

ROLLBACK;
-- parameters.
--Testcase 90:
PREPARE stmt(integer) AS SELECT * FROM shorty WHERE id = $1;
--Testcase 91:
EXECUTE stmt(1);
 id | c 
----+---
  1 | Z
(1 row)

--Testcase 92:
EXECUTE stmt(2);
 id | c 
----+---
  2 | Y
(1 row)

DEALLOCATE stmt;
-- test NULL parameter
--Testcase 93:
SELECT id FROM shorty WHERE c = (SELECT NULL::text);
 id 
----
(0 rows)

-- Use of system column
--Testcase 94:
SELECT tableoid::regclass, * from shorty WHERE id = 1;
 tableoid | id | c 
----------+----+---
 shorty   |  1 | Z
(1 row)

--Testcase 95:
SELECT * from shorty WHERE id = 1 AND tableoid = 'shorty'::regclass;
 id | c 
----+---
  1 | Z
(1 row)

-- Clean up
--Testcase 96:
DROP FOREIGN TABLE shorty;
-- Test rowkey columni with trigger and without trigger
-- Prepare data
--Testcase 97:
INSERT INTO rowkey_tbl VALUES (0, 5);
-- Test with trigger
--Testcase 98:
CREATE FUNCTION row_before_insupd_trigfunc() RETURNS trigger AS $$BEGIN NEW.a := NEW.a + 10; RETURN NEW; END$$ LANGUAGE plpgsql;
--Testcase 99:
CREATE TRIGGER row_before_insupd_trigger BEFORE INSERT OR UPDATE ON rowkey_tbl FOR EACH ROW EXECUTE PROCEDURE row_before_insupd_trigfunc();
--Testcase 100:
INSERT INTO rowkey_tbl VALUES (0, 5);
--Testcase 101:
SELECT * FROM rowkey_tbl;
 a  | b 
----+---
  0 | 5
 10 | 5
(2 rows)

-- This test failed because new rowkey value will be updated to old rowkey value
--Testcase 102:
UPDATE rowkey_tbl SET b = b + 10; -- failed
ERROR:  new rowkey column update is not supported
-- Test without trigger
--Testcase 103:
DROP TRIGGER row_before_insupd_trigger ON rowkey_tbl;
-- This test OK because rowkey value is not changed
--Testcase 104:
UPDATE rowkey_tbl SET b = b + 10; -- ok
--Testcase 105:
SELECT * FROM rowkey_tbl;
 a  | b  
----+----
  0 | 15
 10 | 15
(2 rows)

-- This test failed  because rowkey is updated directly even its value not changed
--Testcase 106:
UPDATE rowkey_tbl SET a = 10, b = b + 15 WHERE a = 10; --failed
ERROR:  rowkey-column update is not supported
--Testcase 107:
SELECT * FROM rowkey_tbl;
 a  | b  
----+----
  0 | 15
 10 | 15
(2 rows)

-- This test failed because new rowkey is updated directly
--Testcase 108:
UPDATE rowkey_tbl SET a = 15, b = b + 15 WHERE a = 10; --failed
ERROR:  rowkey-column update is not supported
--get version
--Testcase 109:
\df griddb*
                                                        List of functions
 Schema |             Name              |      Result data type       |                Argument data types                 | Type 
--------+-------------------------------+-----------------------------+----------------------------------------------------+------
 public | griddb_create_or_replace_stub | boolean                     | func_type text, name_arg text, return_type regtype | func
 public | griddb_disconnect             | boolean                     | text                                               | func
 public | griddb_disconnect_all         | boolean                     |                                                    | func
 public | griddb_fdw_handler            | fdw_handler                 |                                                    | func
 public | griddb_fdw_validator          | void                        | text[], oid                                        | func
 public | griddb_fdw_version            | integer                     |                                                    | func
 public | griddb_get_connections        | SETOF record                | OUT server_name text, OUT valid boolean            | func
 public | griddb_now                    | timestamp without time zone |                                                    | func
 public | griddb_timestamp              | timestamp without time zone | text                                               | func
(9 rows)

--Testcase 110:
SELECT * FROM public.griddb_fdw_version();
 griddb_fdw_version 
--------------------
              20300
(1 row)

--Testcase 111:
SELECT griddb_fdw_version();
 griddb_fdw_version 
--------------------
              20300
(1 row)

--Test pushdown LIMIT...OFFSET
--Testcase 112:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT tableoid::regclass, * FROM onek LIMIT 1 OFFSET 0;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.onek
   Output: (tableoid)::regclass, unique1, unique2, two, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4
   Remote SQL: SELECT  *  FROM onek LIMIT 1 OFFSET 0
(3 rows)

--Testcase 113:
SELECT tableoid::regclass, * FROM onek LIMIT 1 OFFSET 0;
 tableoid | unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
 onek     |     147 |       0 |   1 |    3 |   7 |      7 |       7 |       47 |         147 |       147 |      147 |  14 |   15 | RFAAAA   | AAAAAA   | AAAAxx
(1 row)

--Testcase 114:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT tableoid::regclass, * FROM onek LIMIT 1 OFFSET 10;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.onek
   Output: (tableoid)::regclass, unique1, unique2, two, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4
   Remote SQL: SELECT  *  FROM onek LIMIT 1 OFFSET 10
(3 rows)

--Testcase 115:
SELECT tableoid::regclass, * FROM onek LIMIT 1 OFFSET 10;
 tableoid | unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
 onek     |     489 |      10 |   1 |    1 |   9 |      9 |       9 |       89 |          89 |       489 |      489 |  18 |   19 | VSAAAA   | KAAAAA   | OOOOxx
(1 row)

--Testcase 116:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT ctid, * FROM rowkey_tbl LIMIT 1 OFFSET 0;
                        QUERY PLAN                         
-----------------------------------------------------------
 Foreign Scan on public.rowkey_tbl
   Output: ctid, a, b
   Remote SQL: SELECT  *  FROM rowkey_tbl LIMIT 1 OFFSET 0
(3 rows)

--Testcase 117:
SELECT ctid, * FROM rowkey_tbl LIMIT 1 OFFSET 0;
      ctid      | a | b  
----------------+---+----
 (4294967295,0) | 0 | 15
(1 row)

--Testcase 118:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT ctid, * FROM rowkey_tbl LIMIT 1 OFFSET 1;
                        QUERY PLAN                         
-----------------------------------------------------------
 Foreign Scan on public.rowkey_tbl
   Output: ctid, a, b
   Remote SQL: SELECT  *  FROM rowkey_tbl LIMIT 1 OFFSET 1
(3 rows)

--Testcase 119:
SELECT ctid, * FROM rowkey_tbl LIMIT 1 OFFSET 1;
      ctid      | a  | b  
----------------+----+----
 (4294967295,0) | 10 | 15
(1 row)

--Testcase 120:
EXPLAIN (verbose, costs off)
INSERT INTO ft2 (c1,c2) SELECT c1+1000, c2 || c2 FROM ft2 LIMIT 20 OFFSET 0;
                        QUERY PLAN                         
-----------------------------------------------------------
 Insert on public.ft2
   ->  Foreign Scan on public.ft2 ft2_1
         Output: (ft2_1.c1 + 1000), (ft2_1.c2 || ft2_1.c2)
         Remote SQL: SELECT  *  FROM ft2 LIMIT 20 OFFSET 0
(4 rows)

--Testcase 121:
EXPLAIN (verbose, costs off)
INSERT INTO ft2 (c1,c2) SELECT c1+1000,c2 || c2 FROM ft2 LIMIT 20 OFFSET 5;
                        QUERY PLAN                         
-----------------------------------------------------------
 Insert on public.ft2
   ->  Foreign Scan on public.ft2 ft2_1
         Output: (ft2_1.c1 + 1000), (ft2_1.c2 || ft2_1.c2)
         Remote SQL: SELECT  *  FROM ft2 LIMIT 20 OFFSET 5
(4 rows)

--Testcase 122:
DROP FOREIGN TABLE ft1;
--Testcase 123:
CREATE FOREIGN TABLE ft1 (
	c1 int OPTIONS (rowkey 'true', column_name 'C_1'),
	c2 int NOT NULL,
	c3 text,
	c4 timestamp,
	c5 timestamp,
	c6 text,
	c7 text default 'ft1',
	c8 text
) SERVER griddb_svr OPTIONS (table_name 'T1');
--Testcase 124:
INSERT INTO ft1 (c1, c2) VALUES (100, 100), (200, 200);
--Testcase 125:
EXPLAIN VERBOSE
SELECT c1 FROM ft1 WHERE c1 <= 100;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Foreign Scan on public.ft1  (cost=100.00..166.06 rows=975 width=4)
   Output: c1
   Remote SQL: SELECT  *  FROM "T1" WHERE (("C_1" <= 100))
(3 rows)

--Testcase 126:
SELECT c1 FROM ft1 WHERE c1 <= 100;
 c1  
-----
 100
(1 row)

--Testcase 127:
DELETE FROM ft1;
--Testcase 128:
EXPLAIN (verbose, costs off)
SELECT * FROM
  onek t1
  LEFT JOIN num_data num
  ON num.id = 123,
  LATERAL (SELECT num.id, t2.two FROM onek t2 LIMIT 1 OFFSET 0) AS ss
WHERE t1.ten = ss.id;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: t1.unique1, t1.unique2, t1.two, t1.four, t1.ten, t1.twenty, t1.hundred, t1.thousand, t1.twothousand, t1.fivethous, t1.tenthous, t1.odd, t1.even, t1.stringu1, t1.stringu2, t1.string4, num.idx, num.id, num.val, (num.id), t2.two
   Join Filter: (t1.ten = (num.id))
   ->  Nested Loop Left Join
         Output: t1.unique1, t1.unique2, t1.two, t1.four, t1.ten, t1.twenty, t1.hundred, t1.thousand, t1.twothousand, t1.fivethous, t1.tenthous, t1.odd, t1.even, t1.stringu1, t1.stringu2, t1.string4, num.idx, num.id, num.val
         ->  Foreign Scan on public.onek t1
               Output: t1.unique1, t1.unique2, t1.two, t1.four, t1.ten, t1.twenty, t1.hundred, t1.thousand, t1.twothousand, t1.fivethous, t1.tenthous, t1.odd, t1.even, t1.stringu1, t1.stringu2, t1.string4
               Remote SQL: SELECT  *  FROM onek
         ->  Materialize
               Output: num.idx, num.id, num.val
               ->  Foreign Scan on public.num_data num
                     Output: num.idx, num.id, num.val
                     Remote SQL: SELECT  *  FROM num_data WHERE ((id = 123))
   ->  Foreign Scan on public.onek t2
         Output: num.id, t2.two
         Remote SQL: SELECT  *  FROM onek LIMIT 1 OFFSET 0
(16 rows)

--Testcase 129:
EXPLAIN (verbose, costs off)
SELECT * FROM
  tenk1 t1
  LEFT JOIN num_data num
  ON num.id = 123,
  LATERAL (SELECT num.id, t2.two FROM onek t2 LIMIT 1 OFFSET 5) AS ss1,
  LATERAL (SELECT ss1.* from onek t3 LIMIT 1 OFFSET 20) AS ss2
WHERE t1.ten = ss2.id;
                                                                                                                            QUERY PLAN                                                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: t1.unique1, t1.unique2, t1.two, t1.four, t1.ten, t1.twenty, t1.hundred, t1.thousand, t1.twothousand, t1.fivethous, t1.tenthous, t1.odd, t1.even, t1.stringu1, t1.stringu2, t1.string4, num.idx, num.id, num.val, (num.id), t2.two, ((num.id)), (t2.two)
   Join Filter: (t1.ten = ((num.id)))
   ->  Nested Loop
         Output: t1.unique1, t1.unique2, t1.two, t1.four, t1.ten, t1.twenty, t1.hundred, t1.thousand, t1.twothousand, t1.fivethous, t1.tenthous, t1.odd, t1.even, t1.stringu1, t1.stringu2, t1.string4, num.idx, num.id, num.val, (num.id), t2.two
         ->  Nested Loop Left Join
               Output: t1.unique1, t1.unique2, t1.two, t1.four, t1.ten, t1.twenty, t1.hundred, t1.thousand, t1.twothousand, t1.fivethous, t1.tenthous, t1.odd, t1.even, t1.stringu1, t1.stringu2, t1.string4, num.idx, num.id, num.val
               ->  Foreign Scan on public.tenk1 t1
                     Output: t1.unique1, t1.unique2, t1.two, t1.four, t1.ten, t1.twenty, t1.hundred, t1.thousand, t1.twothousand, t1.fivethous, t1.tenthous, t1.odd, t1.even, t1.stringu1, t1.stringu2, t1.string4
                     Remote SQL: SELECT  *  FROM tenk1
               ->  Materialize
                     Output: num.idx, num.id, num.val
                     ->  Foreign Scan on public.num_data num
                           Output: num.idx, num.id, num.val
                           Remote SQL: SELECT  *  FROM num_data WHERE ((id = 123))
         ->  Foreign Scan on public.onek t2
               Output: num.id, t2.two
               Remote SQL: SELECT  *  FROM onek LIMIT 1 OFFSET 5
   ->  Memoize
         Output: ((num.id)), (t2.two)
         Cache Key: (num.id), t2.two
         Cache Mode: binary
         ->  Foreign Scan on public.onek t3
               Output: (num.id), t2.two
               Remote SQL: SELECT  *  FROM onek LIMIT 1 OFFSET 20
(25 rows)

--Testcase 130:
EXPLAIN (verbose, costs off)
SELECT 1 FROM
  tenk1 AS tt1
  INNER JOIN tenk1 AS tt2 ON (tt1.stringu1 = 'foo')
  LEFT JOIN tenk1 AS tt3 ON (tt3.stringu1 = 'foo')
  LEFT JOIN tenk1 AS tt4 ON (tt3.stringu1 = tt4.stringu2),
  LATERAL (SELECT tt4.ten AS c0 FROM tenk1 AS tt5 LIMIT 1 OFFSET 30) AS ss1
WHERE tt1.ten = ss1.c0;
                                                                                                               QUERY PLAN                                                                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: 1
   Join Filter: (tt1.ten = (tt4.ten))
   ->  Hash Left Join
         Output: tt1.ten, tt4.ten
         Hash Cond: (tt3.stringu1 = tt4.stringu2)
         ->  Nested Loop Left Join
               Output: tt1.ten, tt3.stringu1
               ->  Nested Loop
                     Output: tt1.ten
                     ->  Foreign Scan on public.tenk1 tt2
                           Output: tt2.unique1, tt2.unique2, tt2.two, tt2.four, tt2.ten, tt2.twenty, tt2.hundred, tt2.thousand, tt2.twothousand, tt2.fivethous, tt2.tenthous, tt2.odd, tt2.even, tt2.stringu1, tt2.stringu2, tt2.string4
                           Remote SQL: SELECT  *  FROM tenk1
                     ->  Materialize
                           Output: tt1.ten
                           ->  Foreign Scan on public.tenk1 tt1
                                 Output: tt1.ten
                                 Remote SQL: SELECT  *  FROM tenk1 WHERE ((stringu1 = 'foo'))
               ->  Materialize
                     Output: tt3.stringu1
                     ->  Foreign Scan on public.tenk1 tt3
                           Output: tt3.stringu1
                           Remote SQL: SELECT  *  FROM tenk1 WHERE ((stringu1 = 'foo'))
         ->  Hash
               Output: tt4.ten, tt4.stringu2
               ->  Foreign Scan on public.tenk1 tt4
                     Output: tt4.ten, tt4.stringu2
                     Remote SQL: SELECT  *  FROM tenk1 WHERE ((stringu2 = 'foo'))
   ->  Foreign Scan on public.tenk1 tt5
         Output: tt4.ten
         Remote SQL: SELECT  *  FROM tenk1 LIMIT 1 OFFSET 30
(31 rows)

--Testcase 131:
EXPLAIN (verbose, costs off)
SELECT ss2.* FROM
  tenk1 i41
  LEFT JOIN num_data num
    JOIN (SELECT i42.two AS c1, i43.four AS c2, 42 AS c3
          FROM tenk1 i42, tenk1 i43) ss1
    ON num.id = ss1.c2
  ON i41.two = ss1.c1,
  LATERAL (SELECT i41.*, num.*, ss1.* FROM tenk1 LIMIT 1 OFFSET 10) ss2
WHERE ss1.c2 = 0;
                                                                                                                                                   QUERY PLAN                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: (i41.unique1), (i41.unique2), (i41.two), (i41.four), (i41.ten), (i41.twenty), (i41.hundred), (i41.thousand), (i41.twothousand), (i41.fivethous), (i41.tenthous), (i41.odd), (i41.even), (i41.stringu1), (i41.stringu2), (i41.string4), (num.idx), (num.id), (num.val), (i42.two), (i43.four), ((42))
   ->  Nested Loop
         Output: i41.unique1, i41.unique2, i41.two, i41.four, i41.ten, i41.twenty, i41.hundred, i41.thousand, i41.twothousand, i41.fivethous, i41.tenthous, i41.odd, i41.even, i41.stringu1, i41.stringu2, i41.string4, i42.two, num.idx, num.id, num.val, i43.four, 42
         ->  Nested Loop
               Output: i41.unique1, i41.unique2, i41.two, i41.four, i41.ten, i41.twenty, i41.hundred, i41.thousand, i41.twothousand, i41.fivethous, i41.tenthous, i41.odd, i41.even, i41.stringu1, i41.stringu2, i41.string4, i42.two, num.idx, num.id, num.val
               ->  Hash Join
                     Output: i41.unique1, i41.unique2, i41.two, i41.four, i41.ten, i41.twenty, i41.hundred, i41.thousand, i41.twothousand, i41.fivethous, i41.tenthous, i41.odd, i41.even, i41.stringu1, i41.stringu2, i41.string4, i42.two
                     Hash Cond: (i42.two = i41.two)
                     ->  Foreign Scan on public.tenk1 i42
                           Output: i42.unique1, i42.unique2, i42.two, i42.four, i42.ten, i42.twenty, i42.hundred, i42.thousand, i42.twothousand, i42.fivethous, i42.tenthous, i42.odd, i42.even, i42.stringu1, i42.stringu2, i42.string4
                           Remote SQL: SELECT  *  FROM tenk1
                     ->  Hash
                           Output: i41.unique1, i41.unique2, i41.two, i41.four, i41.ten, i41.twenty, i41.hundred, i41.thousand, i41.twothousand, i41.fivethous, i41.tenthous, i41.odd, i41.even, i41.stringu1, i41.stringu2, i41.string4
                           ->  Foreign Scan on public.tenk1 i41
                                 Output: i41.unique1, i41.unique2, i41.two, i41.four, i41.ten, i41.twenty, i41.hundred, i41.thousand, i41.twothousand, i41.fivethous, i41.tenthous, i41.odd, i41.even, i41.stringu1, i41.stringu2, i41.string4
                                 Remote SQL: SELECT  *  FROM tenk1
               ->  Materialize
                     Output: num.idx, num.id, num.val
                     ->  Foreign Scan on public.num_data num
                           Output: num.idx, num.id, num.val
                           Remote SQL: SELECT  *  FROM num_data WHERE ((id = 0))
         ->  Materialize
               Output: i43.four
               ->  Foreign Scan on public.tenk1 i43
                     Output: i43.four
                     Remote SQL: SELECT  *  FROM tenk1 WHERE ((four = 0))
   ->  Foreign Scan on public.tenk1
         Output: i41.unique1, i41.unique2, i41.two, i41.four, i41.ten, i41.twenty, i41.hundred, i41.thousand, i41.twothousand, i41.fivethous, i41.tenthous, i41.odd, i41.even, i41.stringu1, i41.stringu2, i41.string4, num.idx, num.id, num.val, i42.two, i43.four, (42)
         Remote SQL: SELECT  *  FROM tenk1 LIMIT 1 OFFSET 10
(30 rows)

--Testcase 132:
DROP FUNCTION row_before_insupd_trigfunc;
--Testcase 133:
DROP FOREIGN TABLE rowkey_tbl;
--Testcase 134:
CREATE OR REPLACE FUNCTION drop_all_foreign_tables() RETURNS void AS $$
DECLARE
  tbl_name varchar;
  cmd varchar;
BEGIN
  FOR tbl_name IN SELECT foreign_table_name FROM information_schema._pg_foreign_tables LOOP
    cmd := 'DROP FOREIGN TABLE ' || quote_ident(tbl_name);

--Testcase 135:
    EXECUTE cmd;
  END LOOP;
  RETURN;
END
$$ LANGUAGE plpgsql;
--Testcase 136:
SELECT drop_all_foreign_tables();
 drop_all_foreign_tables 
-------------------------
 
(1 row)

--Testcase 137:
DROP USER MAPPING FOR public SERVER griddb_svr;
--Testcase 138:
DROP SERVER griddb_svr CASCADE;
--Testcase 139:
DROP EXTENSION griddb_fdw CASCADE;
