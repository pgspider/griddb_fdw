--
-- insert with DEFAULT in the target_list
--
CREATE EXTENSION griddb_fdw;
CREATE SERVER griddb_svr FOREIGN DATA WRAPPER griddb_fdw OPTIONS(host '239.0.0.1', port '31999', clustername 'griddbfdwTestCluster');
CREATE USER MAPPING FOR public SERVER griddb_svr OPTIONS(username 'admin', password 'testadmin');
CREATE FOREIGN TABLE inserttest01 (id serial OPTIONS (rowkey 'true'), col1 int4, col2 int4 NOT NULL, col3 text default 'testing') SERVER griddb_svr;
insert into inserttest01 (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);
ERROR:  GridDB-API is failed by 140002 at griddb_fdw.c: 3104

insert into inserttest01 (col2, col3) values (3, DEFAULT);
insert into inserttest01 (col1, col2, col3) values (DEFAULT, 5, DEFAULT);
insert into inserttest01 (col1, col2, col3) values (DEFAULT, 5, 'test');
insert into inserttest01 (col1, col2) values (DEFAULT, 7);
select * from inserttest01;
 id | col1 | col2 |  col3   
----+------+------+---------
  2 |      |    3 | testing
  3 |      |    5 | testing
  4 |      |    5 | test
  5 |      |    7 | testing
(4 rows)

--
-- insert with similar expression / target_list values (all fail)
--
insert into inserttest01 (col1, col2, col3) values (DEFAULT, DEFAULT);
ERROR:  INSERT has more target columns than expressions
LINE 1: insert into inserttest01 (col1, col2, col3) values (DEFAULT,...
                                              ^
insert into inserttest01 (col1, col2, col3) values (1, 2);
ERROR:  INSERT has more target columns than expressions
LINE 1: insert into inserttest01 (col1, col2, col3) values (1, 2);
                                              ^
insert into inserttest01 (col1) values (1, 2);
ERROR:  INSERT has more expressions than target columns
LINE 1: insert into inserttest01 (col1) values (1, 2);
                                                   ^
insert into inserttest01 (col1) values (DEFAULT, DEFAULT);
ERROR:  INSERT has more expressions than target columns
LINE 1: insert into inserttest01 (col1) values (DEFAULT, DEFAULT);
                                                         ^
select * from inserttest01;
 id | col1 | col2 |  col3   
----+------+------+---------
  2 |      |    3 | testing
  3 |      |    5 | testing
  4 |      |    5 | test
  5 |      |    7 | testing
(4 rows)

--
-- VALUES test
--
insert into inserttest01 (col1, col2, col3) values(10, 20, '40'), (-1, 2, DEFAULT),
    ((select 2), (select i from (values(3)) as foo (i)), 'values are fun!');
select * from inserttest01;
 id | col1 | col2 |      col3       
----+------+------+-----------------
  2 |      |    3 | testing
  3 |      |    5 | testing
  4 |      |    5 | test
  5 |      |    7 | testing
  6 |   10 |   20 | 40
  7 |   -1 |    2 | testing
  8 |    2 |    3 | values are fun!
(7 rows)

--
-- TOASTed value test
--
insert into inserttest01 (col1, col2, col3) values(30, 50, repeat('x', 10000));
select col1, col2, char_length(col3) from inserttest01;
 col1 | col2 | char_length 
------+------+-------------
      |    3 |           7
      |    5 |           7
      |    5 |           4
      |    7 |           7
   10 |   20 |           2
   -1 |    2 |           7
    2 |    3 |          15
   30 |   50 |       10000
(8 rows)

drop foreign table inserttest01;
--
-- check indirection (field/array assignment), cf bug #14265
--
-- these tests are aware that transformInsertStmt has 3 separate code paths
--
create foreign table inserttest (f1 serial options (rowkey 'true'), f2 int[], if1 int, if2 text[]) server griddb_svr;
insert into inserttest (f2[1], f2[2]) values (1,2);
insert into inserttest (f2[1], f2[2]) values (3,4), (5,6);
insert into inserttest (f2[1], f2[2]) select 7,8;
insert into inserttest (f2[1], f2[2]) values (1,default);  -- not supported
ERROR:  cannot set an array element to DEFAULT
LINE 1: insert into inserttest (f2[1], f2[2]) values (1,default);
                                       ^
insert into inserttest (if1, if2) values (1,array['foo']);
insert into inserttest (if1, if2) values (1,'{foo}'), (2,'{bar}');
insert into inserttest (if1, if2) select 3, '{baz,quux}';
insert into inserttest (if1, if2) values (1,default);
insert into inserttest (if2[1], if2[2]) values ('foo', 'bar');
insert into inserttest (if2[1], if2[2]) values ('foo', 'bar'), ('baz', 'quux');
insert into inserttest (if2[1], if2[2]) select 'bear', 'beer';
select f1, f2, (if1, if2) as f3 from inserttest;
 f1 |  f2   |        f3        
----+-------+------------------
  1 | {1,2} | (,)
  2 | {3,4} | (,)
  3 | {5,6} | (,)
  4 | {7,8} | (,)
  5 |       | (1,{foo})
  6 |       | (1,{foo})
  7 |       | (2,{bar})
  8 |       | (3,"{baz,quux}")
  9 |       | (1,)
 10 |       | (,"{foo,bar}")
 11 |       | (,"{foo,bar}")
 12 |       | (,"{baz,quux}")
 13 |       | (,"{bear,beer}")
(13 rows)

-- also check reverse-listing
create table inserttest2 (f1 bigint, f2 text);
create rule irule1 as on insert to inserttest2 do also
  insert into inserttest (if2[1], if2[2])
  values (new.f1,new.f2);
create rule irule2 as on insert to inserttest2 do also
  insert into inserttest (if1, if2[2])
  values (1,'fool'),(new.f1,new.f2);
create rule irule3 as on insert to inserttest2 do also
  insert into inserttest (if1, if2[2])
  select new.f1, new.f2;
\d+ inserttest2
                                Table "public.inserttest2"
 Column |  Type  | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+--------+-----------+----------+---------+----------+--------------+-------------
 f1     | bigint |           |          |         | plain    |              | 
 f2     | text   |           |          |         | extended |              | 
Rules:
    irule1 AS
    ON INSERT TO inserttest2 DO  INSERT INTO inserttest (if2[1], if2[2])
  VALUES (new.f1, new.f2)
    irule2 AS
    ON INSERT TO inserttest2 DO  INSERT INTO inserttest (if1, if2[2]) VALUES (1,'fool'::text), (new.f1,new.f2)
    irule3 AS
    ON INSERT TO inserttest2 DO  INSERT INTO inserttest (if1, if2[2])  SELECT new.f1,
            new.f2

drop table inserttest2;
drop foreign table inserttest;
-- direct partition inserts should check partition bound constraint
create table range_parted (
  id serial,
  a text,
  b int
) partition by range (a, (b+0));
-- no partitions, so fail
insert into range_parted(a,b) values ('a', 11);
ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 11).
create foreign table part1 partition of range_parted for values from ('a', 1) to ('a', 10) server griddb_svr;
alter foreign table part1 alter column id options (rowkey 'true');
create foreign table part2 partition of range_parted for values from ('a', 10) to ('a', 20) server griddb_svr;
alter foreign table part2 alter column id options (rowkey 'true');
create foreign table part3 partition of range_parted for values from ('b', 1) to ('b', 10) server griddb_svr;
alter foreign table part3 alter column id options (rowkey 'true');
create foreign table part4 partition of range_parted for values from ('b', 10) to ('b', 20) server griddb_svr;
alter foreign table part4 alter column id options (rowkey 'true');
-- fail, skip because partition bound constraint does not work on GridDB FDW 
--insert into part1(a, b) values ('a', 11);
--insert into part1(a, b) values ('b', 1);
-- ok
insert into part1(a, b) values ('a', 1);
--insert into range_parted(a,b) values ('a', 1);
-- fail, skip because partition bound constraint does not work on GridDB FDW  
--insert into part4(a, b) values ('b', 21);
--insert into part4(a, b) values ('a', 10);
-- ok
insert into part4(a,b) values ('b', 10);
-- fail (partition key a has a NOT NULL constraint)
--insert into part1 values (null);
insert into range_parted values (null);
ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (null, null).
-- fail (expression key (b+0) cannot be null either)
-- skip because partition bound constraint does not work on GridDB FDW  
--insert into part1 values (1);
create table list_parted (
 id serial,
 a text,
 b int
) partition by list (lower(a));
create foreign table part_aa_bb partition of list_parted FOR VALUES IN ('aa', 'bb') server griddb_svr;
alter foreign table part_aa_bb alter column id options (rowkey 'true');
create foreign table part_cc_dd partition of list_parted FOR VALUES IN ('cc', 'dd') server griddb_svr;
alter foreign table part_cc_dd alter column id options (rowkey 'true');
create foreign table part_null partition of list_parted FOR VALUES IN (null) server griddb_svr;
alter foreign table part_null alter column id options (rowkey 'true');
-- fail
-- skip because partition bound constraint does not work on GridDB FDW  
--insert into part_aa_bb(a,b) values ('cc', 1);
--insert into part_aa_bb(a,b) values ('AAa', 1);
--insert into part_aa_bb(a,b) values (null);
-- ok
insert into part_cc_dd(a,b) values ('cC', 1);
insert into part_null(a,b) values (null, 0);
-- check in case of multi-level partitioned table
create table part_ee_ff partition of list_parted for values in ('ee', 'ff') partition by range (b);
create foreign table part_ee_ff1 partition of part_ee_ff for values from (1) to (10) server griddb_svr;
alter foreign table part_ee_ff1 alter column id options (rowkey 'true');
create foreign table part_ee_ff2 partition of part_ee_ff for values from (10) to (20) server griddb_svr;
alter foreign table part_ee_ff2 alter column id options (rowkey 'true');
-- test default partition
create table part_default partition of list_parted default;
-- Negative test: a row, which would fit in other partition, does not fit
-- default partition, even when inserted directly
insert into part_default(a,b) values ('aa', 2);
ERROR:  new row for relation "part_default" violates partition constraint
DETAIL:  Failing row contains (3, aa, 2).
insert into part_default(a,b) values (null, 2);
ERROR:  new row for relation "part_default" violates partition constraint
DETAIL:  Failing row contains (4, null, 2).
-- ok
insert into part_default(a,b) values ('Zz', 2);
-- test if default partition works as expected for multi-level partitioned
-- table as well as when default partition itself is further partitioned
drop table part_default;
create table part_xx_yy partition of list_parted for values in ('xx', 'yy') partition by list (a);
create foreign table part_xx_yy_p1 partition of part_xx_yy for values in ('xx') server griddb_svr;
alter foreign table part_xx_yy_p1 alter column id options (rowkey 'true');
create foreign table part_xx_yy_defpart partition of part_xx_yy default server griddb_svr;
alter foreign table part_xx_yy_defpart alter column id options (rowkey 'true');
create table part_default partition of list_parted default partition by range(b);
create foreign table part_default_p1 partition of part_default for values from (20) to (30) server griddb_svr;
alter foreign table part_default_p1 alter column id options (rowkey 'true');
create foreign table part_default_p2 partition of part_default for values from (30) to (40) server griddb_svr;
alter foreign table part_default_p2 alter column id options (rowkey 'true');
-- fail
-- skip because partition bound constraint does not work on GridDB FDW  
--insert into part_ee_ff1(a,b) values ('EE', 11);
--insert into part_default_p2(a,b) values ('gg', 43);
-- fail (even the parent's, ie, part_ee_ff's partition constraint applies)
-- skip because partition bound constraint does not work on GridDB FDW  
--insert into part_ee_ff1(a,b)  values ('cc', 1);
--insert into part_default(a,b) values ('gg', 43);
-- ok
insert into part_ee_ff1(a,b)  values ('ff', 1);
insert into part_ee_ff2(a,b)  values ('ff', 11);
insert into part_default_p1(a,b)  values ('cd', 25);
insert into part_default_p2(a,b)  values ('de', 35);
insert into list_parted(a,b) values ('ab', 21);
insert into list_parted(a,b) values ('xx', 1);
insert into list_parted(a,b) values ('yy', 2);
select tableoid::regclass, * from list_parted;
      tableoid      | id | a  | b  
--------------------+----+----+----
 part_cc_dd         |  1 | cC |  1
 part_ee_ff1        |  6 | ff |  1
 part_ee_ff2        |  7 | ff | 11
 part_xx_yy_p1      | 11 | xx |  1
 part_xx_yy_defpart | 12 | yy |  2
 part_null          |  2 |    |  0
 part_default_p1    |  8 | cd | 25
 part_default_p1    | 10 | ab | 21
 part_default_p2    |  9 | de | 35
(9 rows)

-- Check tuple routing for partitioned tables
-- fail
insert into range_parted(a,b) values ('a', 0);
ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 0).
-- ok
insert into range_parted(a,b) values ('a', 1);
insert into range_parted(a,b) values ('a', 10);
-- fail
insert into range_parted(a,b) values ('a', 20);
ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 20).
-- ok
insert into range_parted(a,b) values ('b', 1);
insert into range_parted(a,b) values ('b', 10);
-- fail (partition key (b+0) is null)
insert into range_parted(a) values ('a');
ERROR:  no partition of relation "range_parted" found for row
DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, null).
-- Check default partition
create foreign table part_def partition of range_parted default server griddb_svr;
alter foreign table part_def alter column id options (rowkey 'true');
-- fail
-- skip because partition bound constraint does not work on GridDB FDW  
-- insert into part_def(a,b) values ('b', 10);
-- ok
insert into part_def(a,b) values ('c', 10);
insert into range_parted(a,b) values (null, null);
insert into range_parted(a,b) values ('a', null);
insert into range_parted(a,b) values (null, 19);
insert into range_parted(a,b) values ('b', 20);
select tableoid::regclass, * from range_parted;
 tableoid | id | a | b  
----------+----+---+----
 part1    |  2 | a |  1
 part1    |  5 | a |  1
 part2    |  6 | a | 10
 part3    |  8 | b |  1
 part4    |  3 | b | 10
 part4    |  9 | b | 10
 part_def | 11 | c | 10
 part_def | 12 |   |   
 part_def | 13 | a |   
 part_def | 14 |   | 19
 part_def | 15 | b | 20
(11 rows)

-- ok
insert into list_parted(a,b) values (null, 1);
insert into list_parted (a) values ('aA');
-- fail (partition of part_ee_ff not found in both cases)
-- skip because partition bound constraint does not work on GridDB FDW  
insert into list_parted(a,b) values ('EE', 0);
ERROR:  no partition of relation "part_ee_ff" found for row
DETAIL:  Partition key of the failing row contains (b) = (0).
--insert into part_ee_ff(a,b) values ('EE', 0);
-- ok
insert into list_parted(a,b) values ('EE', 1);
insert into part_ee_ff(a,b) values ('EE', 10);
select tableoid::regclass, * from list_parted;
      tableoid      | id | a  | b  
--------------------+----+----+----
 part_aa_bb         | 14 | aA |   
 part_cc_dd         |  1 | cC |  1
 part_ee_ff1        |  6 | ff |  1
 part_ee_ff1        | 16 | EE |  1
 part_ee_ff2        |  7 | ff | 11
 part_ee_ff2        | 17 | EE | 10
 part_xx_yy_p1      | 11 | xx |  1
 part_xx_yy_defpart | 12 | yy |  2
 part_null          |  2 |    |  0
 part_null          | 13 |    |  1
 part_default_p1    |  8 | cd | 25
 part_default_p1    | 10 | ab | 21
 part_default_p2    |  9 | de | 35
(13 rows)

-- some more tests to exercise tuple-routing with multi-level partitioning
create table part_gg partition of list_parted for values in ('gg') partition by range (b);
WARNING:  skipped scanning foreign table "part_default_p1" which is a partition of default partition "part_default"
WARNING:  skipped scanning foreign table "part_default_p2" which is a partition of default partition "part_default"
create table part_gg1 partition of part_gg for values from (minvalue) to (1);
create table part_gg2 partition of part_gg for values from (1) to (10) partition by range (b);
create table part_gg2_1 partition of part_gg2 for values from (1) to (5);
create table part_gg2_2 partition of part_gg2 for values from (5) to (10);
create table part_ee_ff3 partition of part_ee_ff for values from (20) to (30) partition by range (b);
create table part_ee_ff3_1 partition of part_ee_ff3 for values from (20) to (25);
create table part_ee_ff3_2 partition of part_ee_ff3 for values from (25) to (30);
delete from list_parted;
insert into list_parted (a) values ('aa'), ('cc');
insert into list_parted (a,b) select 'Ff', s.a from generate_series(1, 29) s(a);
insert into list_parted (a,b) select 'gg', s.a from generate_series(1, 9) s(a);
insert into list_parted (b) values (1);
select tableoid::regclass::text, a, min(b) as min_b, max(b) as max_b from list_parted group by 1, 2 order by 1;
   tableoid    | a  | min_b | max_b 
---------------+----+-------+-------
 part_aa_bb    | aa |       |      
 part_cc_dd    | cc |       |      
 part_ee_ff1   | Ff |     1 |     9
 part_ee_ff2   | Ff |    10 |    19
 part_ee_ff3_1 | Ff |    20 |    24
 part_ee_ff3_2 | Ff |    25 |    29
 part_gg2_1    | gg |     1 |     4
 part_gg2_2    | gg |     5 |     9
 part_null     |    |     1 |     1
(9 rows)

-- direct partition inserts should check hash partition bound constraint
-- Use hand-rolled hash functions and operator classes to get predictable
-- result on different matchines.  The hash function for int4 simply returns
-- the sum of the values passed to it and the one for text returns the length
-- of the non-empty string value passed to it or 0.
create or replace function part_hashint4_noop(value int4, seed int8)
returns int8 as $$
select value + seed;
$$ language sql immutable;
create operator class part_test_int4_ops
for type int4
using hash as
operator 1 =,
function 2 part_hashint4_noop(int4, int8);
create or replace function part_hashtext_length(value text, seed int8)
RETURNS int8 AS $$
select length(coalesce(value, ''))::int8
$$ language sql immutable;
create operator class part_test_text_ops
for type text
using hash as
operator 1 =,
function 2 part_hashtext_length(text, int8);
create table hash_parted (
 id serial,
 a int
) partition by hash (a part_test_int4_ops);
create foreign table hpart10 partition of hash_parted for values with (modulus 4, remainder 0) server griddb_svr;
alter foreign table hpart10 alter column id options (rowkey 'true');
create foreign table hpart11 partition of hash_parted for values with (modulus 4, remainder 1) server griddb_svr;
alter foreign table hpart11 alter column id options (rowkey 'true');
create foreign table hpart12 partition of hash_parted for values with (modulus 4, remainder 2) server griddb_svr;
alter foreign table hpart12 alter column id options (rowkey 'true');
create foreign table hpart13 partition of hash_parted for values with (modulus 4, remainder 3) server griddb_svr;
alter foreign table hpart13 alter column id options (rowkey 'true');
insert into hash_parted(a) values(generate_series(1,10));
-- direct insert of values divisible by 4 - ok;
insert into hpart10(a) values(12),(16);
-- fail;
--insert into hpart10 values(11);
-- 11 % 4 -> 3 remainder i.e. valid data for hpart13 partition
--insert into hash_parted(a) values(11);
insert into hpart13(a) values(11);
-- view data
select tableoid::regclass as part, a, a%4 as "remainder = a % 4"
from hash_parted order by part;
  part   | a  | remainder = a % 4 
---------+----+-------------------
 hpart10 |  4 |                 0
 hpart10 |  8 |                 0
 hpart10 | 12 |                 0
 hpart10 | 16 |                 0
 hpart11 |  1 |                 1
 hpart11 |  5 |                 1
 hpart11 |  9 |                 1
 hpart12 |  2 |                 2
 hpart12 |  6 |                 2
 hpart12 | 10 |                 2
 hpart13 |  3 |                 3
 hpart13 |  7 |                 3
 hpart13 | 11 |                 3
(13 rows)

-- test \d+ output on a table which has both partitioned and unpartitioned
-- partitions
\d+ list_parted
                                          Partitioned table "public.list_parted"
 Column |  Type   | Collation | Nullable |                 Default                 | Storage  | Stats target | Description 
--------+---------+-----------+----------+-----------------------------------------+----------+--------------+-------------
 id     | integer |           | not null | nextval('list_parted_id_seq'::regclass) | plain    |              | 
 a      | text    |           |          |                                         | extended |              | 
 b      | integer |           |          |                                         | plain    |              | 
Partition key: LIST (lower(a))
Partitions: part_aa_bb FOR VALUES IN ('aa', 'bb'),
            part_cc_dd FOR VALUES IN ('cc', 'dd'),
            part_ee_ff FOR VALUES IN ('ee', 'ff'), PARTITIONED,
            part_gg FOR VALUES IN ('gg'), PARTITIONED,
            part_null FOR VALUES IN (NULL),
            part_xx_yy FOR VALUES IN ('xx', 'yy'), PARTITIONED,
            part_default DEFAULT, PARTITIONED

-- cleanup
drop table range_parted, list_parted;
drop table hash_parted;
-- test that a default partition added as the first partition accepts any value
-- including null
create table list_parted (id serial, a int) partition by list (a);
create foreign table part_default partition of list_parted default server griddb_svr;
alter foreign table part_default alter column id options (rowkey 'true');
\d+ part_default
                                                    Foreign table "public.part_default"
 Column |  Type   | Collation | Nullable |                 Default                 |   FDW options   | Storage | Stats target | Description 
--------+---------+-----------+----------+-----------------------------------------+-----------------+---------+--------------+-------------
 id     | integer |           | not null | nextval('list_parted_id_seq'::regclass) | (rowkey 'true') | plain   |              | 
 a      | integer |           |          |                                         |                 | plain   |              | 
Partition of: list_parted DEFAULT
No partition constraint
Server: griddb_svr

insert into part_default(a) values (null);
insert into part_default(a) values (1);
insert into part_default(a) values (-1);
select tableoid::regclass, a from list_parted;
   tableoid   | a  
--------------+----
 part_default |   
 part_default |  1
 part_default | -1
(3 rows)

-- cleanup
drop table list_parted;
-- more tests for certain multi-level partitioning scenarios
create table mlparted (a int, b int) partition by range (a, b);
create table mlparted1 (b int not null, a int not null) partition by range ((b+0));
create table mlparted11 (like mlparted1);
alter table mlparted11 drop a;
alter table mlparted11 add a int;
alter table mlparted11 drop a;
alter table mlparted11 add a int not null;
-- attnum for key attribute 'a' is different in mlparted, mlparted1, and mlparted11
select attrelid::regclass, attname, attnum
from pg_attribute
where attname = 'a'
 and (attrelid = 'mlparted'::regclass
   or attrelid = 'mlparted1'::regclass
   or attrelid = 'mlparted11'::regclass)
order by attrelid::regclass::text;
  attrelid  | attname | attnum 
------------+---------+--------
 mlparted   | a       |      1
 mlparted1  | a       |      2
 mlparted11 | a       |      4
(3 rows)

alter table mlparted1 attach partition mlparted11 for values from (2) to (5);
alter table mlparted attach partition mlparted1 for values from (1, 2) to (1, 10);
-- check that "(1, 2)" is correctly routed to mlparted11.
insert into mlparted(a, b) values (1, 2);
select tableoid::regclass, * from mlparted;
  tableoid  | a | b 
------------+---+---
 mlparted11 | 1 | 2
(1 row)

-- check that proper message is shown after failure to route through mlparted1
insert into mlparted (a, b) values (1, 5);
ERROR:  no partition of relation "mlparted1" found for row
DETAIL:  Partition key of the failing row contains ((b + 0)) = (5).
truncate mlparted;
alter table mlparted add constraint check_b check (b = 3);
-- have a BR trigger modify the row such that the check_b is violated
create function mlparted11_trig_fn()
returns trigger AS
$$
begin
  NEW.b := 4;
  return NEW;
end;
$$
language plpgsql;
create trigger mlparted11_trig before insert ON mlparted11
  for each row execute procedure mlparted11_trig_fn();
-- check that the correct row is shown when constraint check_b fails after
-- "(1, 2)" is routed to mlparted11 (actually "(1, 4)" would be shown due
-- to the BR trigger mlparted11_trig_fn)
insert into mlparted (a, b) values (1, 2);
ERROR:  new row for relation "mlparted11" violates check constraint "check_b"
DETAIL:  Failing row contains (1, 4).
drop trigger mlparted11_trig on mlparted11;
drop function mlparted11_trig_fn();
-- check that inserting into an internal partition successfully results in
-- checking its partition constraint before inserting into the leaf partition
-- selected by tuple-routing
insert into mlparted1 (a, b) values (2, 3);
ERROR:  new row for relation "mlparted1" violates partition constraint
DETAIL:  Failing row contains (3, 2).
-- check routing error through a list partitioned table when the key is null
create table lparted_nonullpart (a int, b char) partition by list (b);
create foreign table lparted_nonullpart_a partition of lparted_nonullpart for values in ('a') server griddb_svr;
insert into lparted_nonullpart values (1);
ERROR:  no partition of relation "lparted_nonullpart" found for row
DETAIL:  Partition key of the failing row contains (b) = (null).
drop table lparted_nonullpart;
-- check that RETURNING works correctly with tuple-routing
alter table mlparted drop constraint check_b;
create foreign table mlparted12 partition of mlparted1 for values from (5) to (10) server griddb_svr;
create table mlparted2 (b int not null, a int not null);
alter table mlparted attach partition mlparted2 for values from (1, 10) to (1, 20);
create foreign table mlparted3 partition of mlparted for values from (1, 20) to (1, 30) server griddb_svr;
create table mlparted4 (like mlparted);
alter table mlparted4 drop a;
alter table mlparted4 add a int not null;
alter table mlparted attach partition mlparted4 for values from (1, 30) to (1, 40);
with ins (a, b, c) as
  (insert into mlparted (b, a) select s.a, 1 from generate_series(2, 39) s(a) returning tableoid::regclass, *)
  select a, b, min(c), max(c) from ins group by a, b order by 1;
WARNING:  row was updated instead of insert because same row key has already existed.
WARNING:  row was updated instead of insert because same row key has already existed.
WARNING:  row was updated instead of insert because same row key has already existed.
WARNING:  row was updated instead of insert because same row key has already existed.
WARNING:  row was updated instead of insert because same row key has already existed.
WARNING:  row was updated instead of insert because same row key has already existed.
WARNING:  row was updated instead of insert because same row key has already existed.
WARNING:  row was updated instead of insert because same row key has already existed.
WARNING:  row was updated instead of insert because same row key has already existed.
     a      | b | min | max 
------------+---+-----+-----
 mlparted11 | 1 |   2 |   4
 mlparted12 | 1 |   5 |   9
 mlparted2  | 1 |  10 |  19
 mlparted3  | 1 |  20 |  29
 mlparted4  | 1 |  30 |  39
(5 rows)

alter table mlparted add c text;
create table mlparted5 (a int not null, b int not null, c text) partition by list (c);
create table mlparted5a (a int not null, c text, b int not null);
alter table mlparted5 attach partition mlparted5a for values in ('a');
alter table mlparted attach partition mlparted5 for values from (1, 40) to (1, 50);
alter table mlparted add constraint check_b check (a = 1 and b < 45);
insert into mlparted(a, b, c) values (1, 45, 'a');
ERROR:  new row for relation "mlparted5a" violates check constraint "check_b"
DETAIL:  Failing row contains (1, 45, a).
create function mlparted5abrtrig_func() returns trigger as $$ begin new.c = 'b'; return new; end; $$ language plpgsql;
create trigger mlparted5abrtrig before insert on mlparted5a for each row execute procedure mlparted5abrtrig_func();
insert into mlparted5 (a, b, c) values (1, 40, 'a');
ERROR:  new row for relation "mlparted5a" violates partition constraint
DETAIL:  Failing row contains (1, 40, b).
drop table mlparted5;
alter table mlparted drop constraint check_b;
-- Check multi-level default partition
create table mlparted_def partition of mlparted default partition by range(a);
create foreign table mlparted_def1 partition of mlparted_def for values from (40) to (50) server griddb_svr;
create foreign table mlparted_def2 partition of mlparted_def for values from (50) to (60) server griddb_svr;
insert into mlparted(a, b) values (40, 100);
insert into mlparted_def1(a, b) values (42, 100);
insert into mlparted_def2(a, b) values (54, 50);
-- fail
insert into mlparted(a,b) values (70, 100);
ERROR:  no partition of relation "mlparted_def" found for row
DETAIL:  Partition key of the failing row contains (a) = (70).
--skip because does not support partition bound constraint
--insert into mlparted_def1 values (52, 50);
--insert into mlparted_def2 values (34, 50);
-- ok
create foreign table mlparted_defd partition of mlparted_def default server griddb_svr;
insert into mlparted(a, b) values (70, 100);
select tableoid::regclass, * from mlparted_def;
   tableoid    | a  |  b  | c 
---------------+----+-----+---
 mlparted_def1 | 40 | 100 | 
 mlparted_def1 | 42 | 100 | 
 mlparted_def2 | 54 |  50 | 
 mlparted_defd | 70 | 100 | 
(4 rows)

-- Check multi-level tuple routing with attributes dropped from the
-- top-most parent.  First remove the last attribute.
alter table mlparted add d int, add e int;
alter table mlparted drop e;
create table mlparted5 partition of mlparted
  for values from (1, 40) to (1, 50) partition by range (c);
WARNING:  skipped scanning foreign table "mlparted_def1" which is a partition of default partition "mlparted_def"
WARNING:  skipped scanning foreign table "mlparted_def2" which is a partition of default partition "mlparted_def"
WARNING:  skipped scanning foreign table "mlparted_defd" which is a partition of default partition "mlparted_def"
create table mlparted5_ab partition of mlparted5
  for values from ('a') to ('c') partition by list (c);
-- This partitioned table should remain with no partitions.
create table mlparted5_cd partition of mlparted5
  for values from ('c') to ('e') partition by list (c);
create foreign table mlparted5_a partition of mlparted5_ab for values in ('a') server griddb_svr;
create table mlparted5_b (a int, b int, c text, d int);
alter table mlparted5_ab attach partition mlparted5_b for values in ('b');
-- cannot truncate foreign table, drop foreign table.
drop foreign table mlparted_defd;
drop foreign table mlparted3;
drop foreign table mlparted12;
drop foreign table mlparted_def1;
drop foreign table mlparted_def2;
drop foreign table mlparted5_a;
truncate mlparted;
create foreign table mlparted5_a partition of mlparted5_ab for values in ('a') server griddb_svr;
insert into mlparted(a, b, c, d) values (1, 2, 'a', 1);
insert into mlparted(a, b, c, d) values (1, 40, 'a', 1);  -- goes to mlparted5_a
insert into mlparted(a, b, c, d) values (1, 45, 'b', 1);  -- goes to mlparted5_b
insert into mlparted(a, b, c, d) values (1, 45, 'c', 1);  -- goes to mlparted5_cd, fails
ERROR:  no partition of relation "mlparted5_cd" found for row
DETAIL:  Partition key of the failing row contains (c) = (c).
insert into mlparted(a, b, c, d) values (1, 45, 'f', 1);  -- goes to mlparted5, fails
ERROR:  no partition of relation "mlparted5" found for row
DETAIL:  Partition key of the failing row contains (c) = (f).
select tableoid::regclass, * from mlparted order by a, b, c, d;
  tableoid   | a | b  | c | d 
-------------+---+----+---+---
 mlparted11  | 1 |  2 | a | 1
 mlparted5_a | 1 | 40 | a | 1
 mlparted5_b | 1 | 45 | b | 1
(3 rows)

alter table mlparted drop d;
drop foreign table mlparted5_a;
truncate mlparted;
-- Remove the before last attribute.
alter table mlparted add e int, add d int;
alter table mlparted drop e;
create foreign table mlparted5_a partition of mlparted5_ab for values in ('a') server griddb_svr;
insert into mlparted(a, b, c, d) values (1, 2, 'a', 1);
insert into mlparted(a, b, c, d) values (1, 40, 'a', 1);  -- goes to mlparted5_a
WARNING:  row was updated instead of insert because same row key has already existed.
insert into mlparted(a, b, c, d) values (1, 45, 'b', 1);  -- goes to mlparted5_b
insert into mlparted(a, b, c, d) values (1, 45, 'c', 1);  -- goes to mlparted5_cd, fails
ERROR:  no partition of relation "mlparted5_cd" found for row
DETAIL:  Partition key of the failing row contains (c) = (c).
insert into mlparted(a, b, c, d) values (1, 45, 'f', 1);  -- goes to mlparted5, fails
ERROR:  no partition of relation "mlparted5" found for row
DETAIL:  Partition key of the failing row contains (c) = (f).
select tableoid::regclass, * from mlparted order by a, b, c, d;
  tableoid   | a | b  | c | d 
-------------+---+----+---+---
 mlparted11  | 1 |  2 | a | 1
 mlparted5_a | 1 | 40 | a | 1
 mlparted5_b | 1 | 45 | b | 1
(3 rows)

alter table mlparted drop d;
drop table mlparted5;
-- check that message shown after failure to find a partition shows the
-- appropriate key description (or none) in various situations
create table key_desc (a int, b int) partition by list ((a+0));
create table key_desc_1 partition of key_desc for values in (1) partition by range (b);
create user regress_insert_other_user;
grant select (a) on key_desc_1 to regress_insert_other_user;
grant insert on key_desc to regress_insert_other_user;
set role regress_insert_other_user;
-- no key description is shown
insert into key_desc(a, b) values (1, 1);
ERROR:  no partition of relation "key_desc_1" found for row
reset role;
grant select (b) on key_desc_1 to regress_insert_other_user;
set role regress_insert_other_user;
-- key description (b)=(1) is now shown
insert into key_desc(a, b) values (1, 1);
ERROR:  no partition of relation "key_desc_1" found for row
DETAIL:  Partition key of the failing row contains (b) = (1).
-- key description is not shown if key contains expression
insert into key_desc(a, b) values (2, 1);
ERROR:  no partition of relation "key_desc" found for row
reset role;
revoke all on key_desc from regress_insert_other_user;
revoke all on key_desc_1 from regress_insert_other_user;
drop role regress_insert_other_user;
drop table key_desc, key_desc_1;
-- test minvalue/maxvalue restrictions
create table mcrparted (id serial, a int, b int, c int) partition by range (a, abs(b), c);
create foreign table mcrparted0 partition of mcrparted for values from (minvalue, 0, 0) to (1, maxvalue, maxvalue) server griddb_svr;
ERROR:  every bound following MINVALUE must also be MINVALUE
LINE 1: ...partition of mcrparted for values from (minvalue, 0, 0) to (...
                                                             ^
create foreign table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, minvalue) server griddb_svr;
ERROR:  every bound following MAXVALUE must also be MAXVALUE
LINE 1: ...r values from (10, 6, minvalue) to (10, maxvalue, minvalue) ...
                                                             ^
create foreign table mcrparted4 partition of mcrparted for values from (21, minvalue, 0) to (30, 20, minvalue) server griddb_svr;
ERROR:  every bound following MINVALUE must also be MINVALUE
LINE 1: ...ition of mcrparted for values from (21, minvalue, 0) to (30,...
                                                             ^
-- check multi-column range partitioning expression enforces the same
-- constraint as what tuple-routing would determine it to be
create foreign table mcrparted0 partition of mcrparted for values from (minvalue, minvalue, minvalue) to (1, maxvalue, maxvalue) server griddb_svr;
create foreign table mcrparted1 partition of mcrparted for values from (2, 1, minvalue) to (10, 5, 10) server griddb_svr;
create foreign table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, maxvalue) server griddb_svr;
create foreign table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10) server griddb_svr;
create foreign table mcrparted4 partition of mcrparted for values from (21, minvalue, minvalue) to (30, 20, maxvalue) server griddb_svr;
create foreign table mcrparted5 partition of mcrparted for values from (30, 21, 20) to (maxvalue, maxvalue, maxvalue) server griddb_svr;
alter foreign table mcrparted0 alter column id options (rowkey 'true');
alter foreign table mcrparted1 alter column id options (rowkey 'true');
alter foreign table mcrparted2 alter column id options (rowkey 'true');
alter foreign table mcrparted3 alter column id options (rowkey 'true');
alter foreign table mcrparted4 alter column id options (rowkey 'true');
alter foreign table mcrparted5 alter column id options (rowkey 'true');
-- null not allowed in range partition
insert into mcrparted (a,b,c) values (null, null, null);
ERROR:  no partition of relation "mcrparted" found for row
DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (null, null, null).
-- routed to mcrparted0
insert into mcrparted (a,b,c) values (0, 1, 1);
insert into mcrparted0 values (0, 1, 1);
-- routed to mcparted1
insert into mcrparted (a,b,c) values (9, 1000, 1);
insert into mcrparted1(a,b,c) values (9, 1000, 1);
insert into mcrparted (a,b,c) values (10, 5, -1);
insert into mcrparted1(a,b,c) values (10, 5, -1);
insert into mcrparted (a,b,c) values (2, 1, 0);
insert into mcrparted1(a,b,c) values (2, 1, 0);
-- routed to mcparted2
insert into mcrparted (a,b,c) values (10, 6, 1000);
insert into mcrparted2(a,b,c) values (10, 6, 1000);
insert into mcrparted (a,b,c) values (10, 1000, 1000);
insert into mcrparted2(a,b,c) values (10, 1000, 1000);
-- no partition exists, nor does mcrparted3 accept it
insert into mcrparted (a,b,c) values (11, 1, -1);
ERROR:  no partition of relation "mcrparted" found for row
DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (11, 1, -1).
-- skip
--insert into mcrparted3(a,b,c) values (11, 1, -1);
-- routed to mcrparted5
insert into mcrparted (a,b,c) values (30, 21, 20);
insert into mcrparted5(a,b,c) values(30, 21, 20);
-- skip
--insert into mcrparted4(a,b,c) values (30, 21, 20);	-- error
-- check rows
select tableoid::regclass::text, * from mcrparted order by 1;
  tableoid  | id | a  |  b   |  c   
------------+----+----+------+------
 mcrparted0 |  2 |  0 |    1 |    1
 mcrparted0 |  0 |  1 |    1 |     
 mcrparted1 |  3 |  9 | 1000 |    1
 mcrparted1 |  4 |  9 | 1000 |    1
 mcrparted1 |  5 | 10 |    5 |   -1
 mcrparted1 |  6 | 10 |    5 |   -1
 mcrparted1 |  7 |  2 |    1 |    0
 mcrparted1 |  8 |  2 |    1 |    0
 mcrparted2 |  9 | 10 |    6 | 1000
 mcrparted2 | 10 | 10 |    6 | 1000
 mcrparted2 | 11 | 10 | 1000 | 1000
 mcrparted2 | 12 | 10 | 1000 | 1000
 mcrparted5 | 14 | 30 |   21 |   20
 mcrparted5 | 15 | 30 |   21 |   20
(14 rows)

-- cleanup
drop table mcrparted;
-- check that a BR constraint can't make partition contain violating rows
create table brtrigpartcon (a int, b text) partition by list (a);
create foreign table brtrigpartcon1 partition of brtrigpartcon for values in (1) server griddb_svr;
create or replace function brtrigpartcon1trigf() returns trigger as $$begin new.a := 2; return new; end$$ language plpgsql;
create trigger brtrigpartcon1trig before insert on brtrigpartcon1 for each row execute procedure brtrigpartcon1trigf();
-- ignore, no partition bound constraint check
insert into brtrigpartcon values (1, 'hi there');
insert into brtrigpartcon1 values (1, 'hi there');
WARNING:  row was updated instead of insert because same row key has already existed.
-- check that the message shows the appropriate column description in a
-- situation where the partitioned table is not the primary ModifyTable node
create foreign table inserttest3 (f1 text default 'foo', f2 text default 'bar', f3 int) server griddb_svr;
create role regress_coldesc_role;
grant insert on inserttest3 to regress_coldesc_role;
grant insert on brtrigpartcon to regress_coldesc_role;
revoke select on brtrigpartcon from regress_coldesc_role;
set role regress_coldesc_role;
--ignore, no partition bound constraint check
with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)
  insert into inserttest3 (f3) select * from result;
WARNING:  row was updated instead of insert because same row key has already existed.
reset role;
-- cleanup
revoke all on inserttest3 from regress_coldesc_role;
revoke all on brtrigpartcon from regress_coldesc_role;
drop role regress_coldesc_role;
drop foreign table inserttest3;
drop table brtrigpartcon;
drop function brtrigpartcon1trigf();
-- check that "do nothing" BR triggers work with tuple-routing (this checks
-- that estate->es_result_relation_info is appropriately set/reset for each
-- routed tuple)
create table donothingbrtrig_test (a int, b text) partition by list (a);
create foreign table donothingbrtrig_test1 (a int, b text) server griddb_svr;
create foreign table donothingbrtrig_test2 (a int, b text, c text) server griddb_svr;
alter table donothingbrtrig_test2 drop column c;
create or replace function donothingbrtrig_func() returns trigger as $$begin raise notice 'b: %', new.b; return NULL; end$$ language plpgsql;
create trigger donothingbrtrig1 before insert on donothingbrtrig_test1 for each row execute procedure donothingbrtrig_func();
create trigger donothingbrtrig2 before insert on donothingbrtrig_test2 for each row execute procedure donothingbrtrig_func();
alter table donothingbrtrig_test attach partition donothingbrtrig_test1 for values in (1);
alter table donothingbrtrig_test attach partition donothingbrtrig_test2 for values in (2);
insert into donothingbrtrig_test values (1, 'foo'), (2, 'bar');
NOTICE:  b: foo
NOTICE:  b: bar
copy donothingbrtrig_test from stdin;
NOTICE:  b: baz
NOTICE:  b: qux
select tableoid::regclass, * from donothingbrtrig_test;
 tableoid | a | b 
----------+---+---
(0 rows)

-- cleanup
drop table donothingbrtrig_test;
drop function donothingbrtrig_func();
-- check multi-column range partitioning with minvalue/maxvalue constraints
create table mcrparted (a text, b int) partition by range(a, b);
create foreign table mcrparted1_lt_b partition of mcrparted for values from (minvalue, minvalue) to ('b', minvalue) server griddb_svr;
create foreign table mcrparted2_b partition of mcrparted for values from ('b', minvalue) to ('c', minvalue) server griddb_svr;
create foreign table mcrparted3_c_to_common partition of mcrparted for values from ('c', minvalue) to ('common', minvalue) server griddb_svr;
create foreign table mcrparted4_common_lt_0 partition of mcrparted for values from ('common', minvalue) to ('common', 0) server griddb_svr;
create foreign table mcrparted5_common_0_to_10 partition of mcrparted for values from ('common', 0) to ('common', 10) server griddb_svr;
create foreign table mcrparted6_common_ge_10 partition of mcrparted for values from ('common', 10) to ('common', maxvalue) server griddb_svr;
create foreign table mcrparted7_gt_common_lt_d partition of mcrparted for values from ('common', maxvalue) to ('d', minvalue) server griddb_svr;
create foreign table mcrparted8_ge_d partition of mcrparted for values from ('d', minvalue) to (maxvalue, maxvalue) server griddb_svr;
\d+ mcrparted
                           Partitioned table "public.mcrparted"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 a      | text    |           |          |         | extended |              | 
 b      | integer |           |          |         | plain    |              | 
Partition key: RANGE (a, b)
Partitions: mcrparted1_lt_b FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE),
            mcrparted2_b FOR VALUES FROM ('b', MINVALUE) TO ('c', MINVALUE),
            mcrparted3_c_to_common FOR VALUES FROM ('c', MINVALUE) TO ('common', MINVALUE),
            mcrparted4_common_lt_0 FOR VALUES FROM ('common', MINVALUE) TO ('common', 0),
            mcrparted5_common_0_to_10 FOR VALUES FROM ('common', 0) TO ('common', 10),
            mcrparted6_common_ge_10 FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE),
            mcrparted7_gt_common_lt_d FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE),
            mcrparted8_ge_d FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)

\d+ mcrparted1_lt_b
                                 Foreign table "public.mcrparted1_lt_b"
 Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
 a      | text    |           |          |         |             | extended |              | 
 b      | integer |           |          |         |             | plain    |              | 
Partition of: mcrparted FOR VALUES FROM (MINVALUE, MINVALUE) TO ('b', MINVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a < 'b'::text))
Server: griddb_svr

\d+ mcrparted2_b
                                   Foreign table "public.mcrparted2_b"
 Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
 a      | text    |           |          |         |             | extended |              | 
 b      | integer |           |          |         |             | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('b', MINVALUE) TO ('c', MINVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'b'::text) AND (a < 'c'::text))
Server: griddb_svr

\d+ mcrparted3_c_to_common
                              Foreign table "public.mcrparted3_c_to_common"
 Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
 a      | text    |           |          |         |             | extended |              | 
 b      | integer |           |          |         |             | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('c', MINVALUE) TO ('common', MINVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'c'::text) AND (a < 'common'::text))
Server: griddb_svr

\d+ mcrparted4_common_lt_0
                              Foreign table "public.mcrparted4_common_lt_0"
 Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
 a      | text    |           |          |         |             | extended |              | 
 b      | integer |           |          |         |             | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('common', MINVALUE) TO ('common', 0)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b < 0))
Server: griddb_svr

\d+ mcrparted5_common_0_to_10
                            Foreign table "public.mcrparted5_common_0_to_10"
 Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
 a      | text    |           |          |         |             | extended |              | 
 b      | integer |           |          |         |             | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('common', 0) TO ('common', 10)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 0) AND (b < 10))
Server: griddb_svr

\d+ mcrparted6_common_ge_10
                             Foreign table "public.mcrparted6_common_ge_10"
 Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
 a      | text    |           |          |         |             | extended |              | 
 b      | integer |           |          |         |             | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('common', 10) TO ('common', MAXVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a = 'common'::text) AND (b >= 10))
Server: griddb_svr

\d+ mcrparted7_gt_common_lt_d
                            Foreign table "public.mcrparted7_gt_common_lt_d"
 Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
 a      | text    |           |          |         |             | extended |              | 
 b      | integer |           |          |         |             | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('common', MAXVALUE) TO ('d', MINVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a > 'common'::text) AND (a < 'd'::text))
Server: griddb_svr

\d+ mcrparted8_ge_d
                                 Foreign table "public.mcrparted8_ge_d"
 Column |  Type   | Collation | Nullable | Default | FDW options | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+-------------+----------+--------------+-------------
 a      | text    |           |          |         |             | extended |              | 
 b      | integer |           |          |         |             | plain    |              | 
Partition of: mcrparted FOR VALUES FROM ('d', MINVALUE) TO (MAXVALUE, MAXVALUE)
Partition constraint: ((a IS NOT NULL) AND (b IS NOT NULL) AND (a >= 'd'::text))
Server: griddb_svr

insert into mcrparted values ('aaa', 0), ('b', 0), ('bz', 10), ('c', -10),
    ('comm', -10), ('common', -10), ('common', 0), ('common', 10),
    ('commons', 0), ('d', -10), ('e', 0);
select tableoid::regclass, * from mcrparted order by a, b;
         tableoid          |    a    |  b  
---------------------------+---------+-----
 mcrparted1_lt_b           | aaa     |   0
 mcrparted2_b              | b       |   0
 mcrparted2_b              | bz      |  10
 mcrparted3_c_to_common    | c       | -10
 mcrparted3_c_to_common    | comm    | -10
 mcrparted4_common_lt_0    | common  | -10
 mcrparted5_common_0_to_10 | common  |   0
 mcrparted6_common_ge_10   | common  |  10
 mcrparted7_gt_common_lt_d | commons |   0
 mcrparted8_ge_d           | d       | -10
 mcrparted8_ge_d           | e       |   0
(11 rows)

drop table mcrparted;
-- check that wholerow vars in the RETURNING list work with partitioned tables
create table returningwrtest (a int) partition by list (a);
create foreign table returningwrtest1 partition of returningwrtest for values in (1) server griddb_svr;
insert into returningwrtest values (1) returning returningwrtest;
 returningwrtest 
-----------------
 (1)
(1 row)

-- check also that the wholerow vars in RETURNING list are converted as needed
alter table returningwrtest add b text;
create foreign table returningwrtest2 (a int, b text, c int) server griddb_svr;
alter foreign table returningwrtest2 drop c;
alter table returningwrtest attach partition returningwrtest2 for values in (2);
insert into returningwrtest(a, b) values (2, 'foo') returning returningwrtest;
 returningwrtest 
-----------------
 (2,foo)
(1 row)

drop table returningwrtest;
-- drop all foreign tables
DO $d$
declare
  l_rec record;
begin
  for l_rec in (select foreign_table_schema, foreign_table_name 
                from information_schema.foreign_tables) loop
     execute format('drop foreign table %I.%I cascade;', l_rec.foreign_table_schema, l_rec.foreign_table_name);
  end loop;
end;
$d$;
DROP USER MAPPING FOR public SERVER griddb_svr;
DROP SERVER griddb_svr;
DROP EXTENSION griddb_fdw CASCADE;
